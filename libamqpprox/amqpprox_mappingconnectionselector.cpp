/*
** Copyright 2020 Bloomberg Finance L.P.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/
#include <amqpprox_mappingconnectionselector.h>

#include <amqpprox_backend.h>
#include <amqpprox_backendset.h>
#include <amqpprox_backendstore.h>
#include <amqpprox_connectionmanager.h>
#include <amqpprox_farmstore.h>
#include <amqpprox_logging.h>
#include <amqpprox_resourcemapper.h>
#include <amqpprox_sessionstate.h>

#include <iostream>

namespace Bloomberg {
namespace amqpprox {

MappingConnectionSelector::MappingConnectionSelector(
    FarmStore      *farmStore,
    BackendStore   *backendStore,
    ResourceMapper *resourceMapper)
: d_farmStore_p(farmStore)
, d_backendStore_p(backendStore)
, d_resourceMapper_p(resourceMapper)
, d_defaultFarmName("")
, d_indexes()
, d_mutex()
{
}

MappingConnectionSelector::~MappingConnectionSelector()
{
}

int MappingConnectionSelector::acquireConnection(
    std::shared_ptr<ConnectionManager> *connectionOut,
    const SessionState                 &state)
{
    std::shared_ptr<ConnectionManager> connectionManager;

    bool        isFarm = false;
    std::string resourceName;

    if (!d_resourceMapper_p->getResourceMap(&isFarm, &resourceName, state)) {
        std::lock_guard<std::mutex> lg(d_mutex);
        if (d_defaultFarmName.empty()) {
            LOG_INFO << "No farm available for: " << state;
            return 1;
        }
        else {
            isFarm       = true;
            resourceName = d_defaultFarmName;
        }
    }

    if (isFarm) {
        // Return the BackendSet and BackendSelector generated by the Farm
        try {
            const auto &farm = d_farmStore_p->getFarmByName(resourceName);

            connectionManager.reset(new ConnectionManager(
                farm.backendSet(), farm.backendSelector()));
        }
        catch (std::runtime_error &e) {
            LOG_WARN << "Unable to acquire backend from Farm: " << resourceName
                     << " for: " << state;
            return 4;
        }

        LOG_INFO << "Selected farm: " << resourceName << " For " << state;
    }
    else {
        // Construct a BackendSet directly and pass a nullptr BackendSelector
        auto backend = d_backendStore_p->lookup(resourceName);
        if (!backend) {
            return 3;
        }

        std::vector<BackendSet::Partition> partitions = {{backend}};

        connectionManager.reset(new ConnectionManager(
            std::make_shared<BackendSet>(std::move(partitions)), nullptr));

        LOG_INFO << "Selected directly: " << *backend << " For " << state;
    }

    connectionOut->swap(connectionManager);

    return 0;
}

void MappingConnectionSelector::setDefaultFarm(const std::string &farmName)
{
    std::lock_guard<std::mutex> lg(d_mutex);
    d_defaultFarmName = farmName;
}

void MappingConnectionSelector::unsetDefaultFarm()
{
    std::lock_guard<std::mutex> lg(d_mutex);
    d_defaultFarmName = "";
}

}
}
